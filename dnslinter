#!/usr/bin/env perl

use strict;
use warnings;
use v5.10;

use Data::Dumper;
use File::Basename;
use Getopt::Long::Descriptive;
use IO::All;
use NetAddr::IP qw(:lower);
use Net::Ping;
use Socket qw(:DEFAULT getaddrinfo getnameinfo inet_pton NI_NAMEREQD NI_NUMERICHOST NIx_NOSERV);

my ( $opt, $usage ) = describe_options(
    "%c %o",
    [ 'networks|n=s', 'A comma separated list of networks, or name of a file containing networks, one per line.', { required => 1 } ],
    [ 'ping|p',       'Enable ping checks - requires root.' ],
    [ 'verbose|v',    'Explain what is happening.' ],
    [ 'fail|f',       'Report failing DNS mappings.',                                                             { default  => 1 } ],
    [ 'okay|o',       'Report okay DNS mappings.' ],
    [ 'summary|s',    'Show a summary of findings.' ],
);

my $network = $opt->networks;
my $ping    = $opt->ping;
my $verbose = $opt->verbose;
my $fail    = $opt->fail;
my $okay    = $opt->okay;
my $summary = $opt->summary;

my $pinger;

my $errors      = 0;
my $okays       = 0;
my $pingables   = 0;
my $unpingables = 0;
my $tested      = 0;

eval {
    if ($ping) {
        $pinger = Net::Ping->new( 'icmp', 2 );
    }
};

if ( $@ =~ /icmp ping requires root privilege/ ) {
    fail('Ping checks require root privilege to run.');
    exit 1;
}

my @ipranges = get_netblocks();

foreach my $range (@ipranges) {
    verbose("Processing '$range'.");

    my $thisrange = new NetAddr::IP($range);
    my $ip        = $thisrange->first();
    my $lastip    = $thisrange->last();
    my $ipcount   = $thisrange->num();

    warn $ipcount;

    while ( $ipcount > 0 ) {
        $ipcount--;
        my $thisip = $ip->short();

        verbose("Pondering $thisip.");
        $tested++;
        my ( $err, $hostname, $port ) = getnameinfo( pack_sockaddr_in6( 0, inet_pton( AF_INET6, $thisip ) ), NI_NAMEREQD, NI_NAMEREQD );
        unless ($err) {
            verbose("$thisip resolves to $hostname");
        }

        if ($ping) {
            verbose("Pinging $thisip");
            my $pinged = $pinger->ping($thisip);
            $pingables++ if $pinged;

            if ( $pinged && ( !defined $hostname ) ) {
                fail("$thisip responds to pings but has no PTR.");
                $errors++;
                next;
            }
            $unpingables++ unless $pinged;
        }

        next unless defined $hostname;

        my @addresses;
        my @results;

        ( $err, @results ) = getaddrinfo( $hostname, "", { socktype => SOCK_RAW } );
        while ( my $ai = shift @results ) {
            my ( $err, $ipaddr ) = getnameinfo( $ai->{addr}, NI_NUMERICHOST, NIx_NOSERV );
            push @addresses, $ipaddr unless $err;
        }

        my $found = scalar grep( /^$thisip$/, @addresses );
        if ( $found == 0 ) {
            fail("No PTR present for $hostname -> $thisip.");
            $errors++;
        } else {
            okay("PTR present for $thisip -> $hostname.");
            $okays++;
        }

    }
}

if ($summary) {
    my $text = "Summary: $tested IP";
    $text .= $tested != 1 ? 's' : '';
    $text .= " tested, $okays okay, $errors error";
    $text .= $errors != 1 ? 's' : '';
    if ($ping) {
        $text .= ", $pingables pingable, $unpingables unpingable";
    }
    $text .= ".";
    say $text;
}

sub get_netblocks {
    my @blocks   = ();
    my $networks = $opt->networks;

    if ( -e "$networks" ) {
        @blocks = io("$networks")->slurp;
        chomp(@blocks);
    } else {
        @blocks = split( /,/, $networks );
    }

    return @blocks;
}

sub fail {
    return unless $fail || $verbose;
    my $message = shift;
    say "FAIL: $message";
}

sub okay {
    return unless $okay || $verbose;
    my $message = shift;
    say "OK: $message";
}

sub verbose {
    return unless $verbose;
    my $message = shift;
    say "INFO: $message";
}
